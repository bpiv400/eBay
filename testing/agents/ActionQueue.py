from agent.util import get_agent_name
from rlenv.Heap import Heap
from testing.Action import Action
from testing.util import compare_input_dicts


class ActionQueue:
    def __init__(self, byr=False):
        self.byr = byr
        self.model_name = get_agent_name(byr=self.byr)
        self.action_queue = Heap(entry_type=Action)

    def push_action(self, action=None):
        self.action_queue.push(action)

    def get_action(self, agent_tuple=None):
        obs, _, done, info = agent_tuple
        obs = obs._asdict()
        # check that turn matches agents type
        next_action = self.action_queue.pop()  # type: Action
        # if the tuple isn't a dummy generated by reset wrapper
        if info is not None:
            assert (info.turn % 2 == 1 and self.byr) or (not self.byr and info.turn % 2 == 0)
            # check that turns match
            assert next_action.turn == info.turn
            # if not the first turn, check that thread id matches
            if next_action.turn != 1:
                if next_action.thread_id is None and info.thread_id == 0:
                    pass
                elif next_action.thread_id != info.thread_id:
                    raise RuntimeError('Invalid thread ids: ({}, {})'.format(
                        next_action.thread_id, info.thread_id))
            # check that time is the same
            if next_action.time != info.priority:
                raise RuntimeError('Different priorities: ({}, {})'.format(
                    next_action.time, info.priority))
        else:
            assert (next_action.turn == 1 and self.byr) or \
                   (next_action.turn % 2 == 0 and not self.byr)
        if not next_action.censored:
            for feat_set in obs.keys():
                obs[feat_set] = obs[feat_set].unsqueeze(0)
            compare_input_dicts(model=self.model_name,
                                stored_inputs=next_action.input_dict,
                                env_inputs=obs)
        return next_action.con

    def verify_done(self):
        while not self.action_queue.empty:
            next_action = self.action_queue.pop()
            if not next_action.censored:
                raise RuntimeError('Thread {}, turn {} not censored'.format(
                    next_action.thread_id, next_action.turn))
